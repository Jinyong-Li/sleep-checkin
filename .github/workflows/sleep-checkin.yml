name: Sleep check-in

on:
  issue_comment:
    types: [created]

permissions:
  issues: write

concurrency:
  group: sleep-checkin-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  log:
    if: ${{ github.event.issue.pull_request == null }}
    runs-on: ubuntu-latest
    steps:
      - name: Handle /sleep /wake /rebuild /undo
        uses: actions/github-script@v7
        with:
          script: |
            // ----------------------------
            // Config
            // ----------------------------
            const REQUIRED_LABEL = 'sleep-log';

            const BACKFILL_KEYWORD = 'backfill';
            const BACKFILL_MAX_DAYS = 7;

            const UNDO_MAX_MINUTES = 10;

            const RECENT_DAYS = 30;

            // 04:00 (UTC+8): sleep before this hour counts as "previous night" (dateKey - 1 day)
            const CUTOFF_HOUR = 4;

            const TITLE_PREFIX = '[Sleep Log]';

            // Anti-tamper: only trust events emitted by github-actions[bot]
            const TRUSTED_EVENT_AUTHOR = 'github-actions[bot]';
            const EVENT_PREFIX = '<!--SLEEP_LOG_EVENT ';
            const EVENT_SUFFIX = '-->';

            // Cached state marker (written to issue body by bot)
            const STATE_PREFIX = '<!-- SLEEP_LOG_STATE ';
            const STATE_SUFFIX = ' -->';

            const ENFORCE_SINGLE_OPEN_ISSUE_PER_USER = true;

            // ----------------------------
            // Helpers: date/time
            // ----------------------------
            const pad = (n) => String(n).padStart(2, '0');

            function toUtc8Date(dateUtcIso) {
              const dt = new Date(dateUtcIso); // UTC
              return new Date(dt.getTime() + 8 * 60 * 60 * 1000);
            }

            function fmtUtc8Stamp(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              const HH = pad(dateObjUtc8.getUTCHours());
              const MM = pad(dateObjUtc8.getUTCMinutes());
              return `${yyyy}-${mm}-${dd} ${HH}:${MM}`;
            }

            function fmtUtc8DateKey(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              return `${yyyy}-${mm}-${dd}`;
            }

            function addDaysToUtc8DateKey(dateKey, deltaDays) {
              const m = dateKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
              if (!m) return null;

              const [, Y, M, D] = m;

              // UTC+8 midnight -> UTC time = midnight - 8h
              const utcMs = Date.UTC(Number(Y), Number(M) - 1, Number(D), -8, 0, 0);
              const newUtcMs = utcMs + deltaDays * 24 * 60 * 60 * 1000;
              const newUtc8 = new Date(newUtcMs + 8 * 60 * 60 * 1000);
              return fmtUtc8DateKey(newUtc8);
            }

            function minutesBetweenUtc8Stamps(sleepStamp, wakeStamp) {
              const m1 = sleepStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              const m2 = wakeStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              if (!m1 || !m2) return null;

              const [, Y1, M1, D1, h1, mi1] = m1;
              const [, Y2, M2, D2, h2, mi2] = m2;

              const t1 = Date.UTC(Number(Y1), Number(M1) - 1, Number(D1), Number(h1) - 8, Number(mi1));
              const t2 = Date.UTC(Number(Y2), Number(M2) - 1, Number(D2), Number(h2) - 8, Number(mi2));
              return Math.round((t2 - t1) / 60000);
            }

            function dateKeyForSleepEvent(utc8DateObj) {
              const hour = utc8DateObj.getUTCHours();
              const todayKey = fmtUtc8DateKey(utc8DateObj);
              if (hour < CUTOFF_HOUR) return addDaysToUtc8DateKey(todayKey, -1);
              return todayKey;
            }

            // ----------------------------
            // Helpers: table & state markers
            // ----------------------------
            function ensureTableBlock(issueBody) {
              const startMark = '<!-- SLEEP_LOG_TABLE_START -->';
              const endMark = '<!-- SLEEP_LOG_TABLE_END -->';

              let body = issueBody || '';
              if (!body.includes(startMark) || !body.includes(endMark)) {
                body =
                  `${body}\n\n${startMark}\n\n` +
                  `${endMark}\n`;
              }
              return { body, startMark, endMark };
            }

            function extractTable(body, startMark, endMark) {
              const startIdx = body.indexOf(startMark);
              const endIdx = body.indexOf(endMark);
              const before = body.slice(0, startIdx + startMark.length);
              const middle = body.slice(startIdx + startMark.length, endIdx);
              const after = body.slice(endIdx);
              return { before, middle, after };
            }

            function computeDuration(entry) {
              entry.duration = '';
              if (entry.sleep && entry.wake) {
                const diffMin = minutesBetweenUtc8Stamps(entry.sleep, entry.wake);
                if (diffMin != null && diffMin >= 0 && diffMin <= 24 * 60) {
                  const h = Math.floor(diffMin / 60);
                  const m = diffMin % 60;
                  entry.duration = `${h}h${pad(m)}m`;
                }
              }
            }

            function normalizeEntry(e) {
              const entry = {
                sleep: e?.sleep || '',
                wake: e?.wake || '',
                duration: e?.duration || '',
                source: e?.source || '',
              };
              computeDuration(entry);
              return entry;
            }

            function sortedDateKeysDesc(objKeys) {
              return [...objKeys].sort((a, b) => (a < b ? 1 : -1));
            }

            function buildRowsObjectToMap(rowsObj) {
              const map = new Map();
              for (const [k, v] of Object.entries(rowsObj || {})) {
                map.set(k, normalizeEntry(v));
              }
              return map;
            }

            function buildMapToRowsObject(map) {
              const rows = {};
              for (const [k, v] of map.entries()) {
                rows[k] = {
                  sleep: v.sleep || '',
                  wake: v.wake || '',
                  duration: v.duration || '',
                  source: v.source || '',
                };
              }
              return rows;
            }

            function buildTableMarkdownFromMap(map, keysDesc) {
              const out = [
                '| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |',
                '|---|---|---|---|---|',
              ];

              for (const k of keysDesc) {
                const e = map.get(k) || { sleep: '', wake: '', duration: '', source: '' };
                out.push(`| ${k} | ${e.sleep || ''} | ${e.wake || ''} | ${e.duration || ''} | ${e.source || ''} |`);
              }

              return out.join('\n');
            }

            function buildTableMiddle(map, todayKey) {
              const allKeys = sortedDateKeysDesc(Array.from(map.keys()));
              const minRecent = addDaysToUtc8DateKey(todayKey, -(RECENT_DAYS - 1));
              const recentKeys = allKeys.filter((k) => !minRecent || (k >= minRecent && k <= todayKey));

              const recentTable = buildTableMarkdownFromMap(map, recentKeys);
              const allTable = buildTableMarkdownFromMap(map, allKeys);

              return (
                `\n\n` +
                `### Recent (last ${RECENT_DAYS} days)\n\n` +
                `${recentTable}\n\n` +
                `<details>\n` +
                `<summary>All history</summary>\n\n` +
                `${allTable}\n\n` +
                `</details>\n\n`
              );
            }

            function parseStateFromBody(body) {
              const start = (body || '').indexOf(STATE_PREFIX);
              if (start < 0) return null;
              const jsonStart = start + STATE_PREFIX.length;
              const end = (body || '').indexOf(STATE_SUFFIX, jsonStart);
              if (end < 0) return null;
              const jsonText = (body || '').slice(jsonStart, end).trim();
              try {
                const st = JSON.parse(jsonText);
                if (!st || typeof st !== 'object') return null;
                if (typeof st.cursor !== 'number') return null;
                if (!st.rows || typeof st.rows !== 'object') return null;
                return st;
              } catch {
                return null;
              }
            }

            function upsertStateIntoBody(body, stateObj) {
              const json = JSON.stringify(stateObj);
              const marker = `${STATE_PREFIX}${json}${STATE_SUFFIX}`;

              const start = (body || '').indexOf(STATE_PREFIX);
              if (start < 0) {
                // append at end
                return `${body || ''}\n\n${marker}\n`;
              }

              const jsonStart = start + STATE_PREFIX.length;
              const end = (body || '').indexOf(STATE_SUFFIX, jsonStart);
              if (end < 0) {
                // broken marker: remove everything after prefix and append fresh marker
                return `${(body || '').slice(0, start).trimEnd()}\n\n${marker}\n`;
              }

              return (body || '').slice(0, start) + marker + (body || '').slice(end + STATE_SUFFIX.length);
            }

            // ----------------------------
            // Helpers: commands & events
            // ----------------------------
            function parseCommand(text) {
              // /sleep
              // /wake
              // /sleep YYYY-MM-DD HH:MM backfill
              // /wake  YYYY-MM-DD HH:MM backfill
              // /rebuild
              // /undo
              const parts = (text || '').trim().split(/\s+/).filter(Boolean);
              const cmd = (parts[0] || '').toLowerCase();

              if (cmd === '/rebuild') return { cmd };
              if (cmd === '/undo') return { cmd };

              if (cmd !== '/sleep' && cmd !== '/wake') return null;

              let explicitDate = null;
              let explicitTime = null;
              let isBackfill = false;

              if (parts.length === 2) {
                // Disallow "/sleep HH:MM" and "/wake HH:MM" (no date)
                if (/^\d{2}:\d{2}$/.test(parts[1])) {
                  explicitTime = parts[1];
                }
              } else if (parts.length >= 3) {
                if (/^\d{4}-\d{2}-\d{2}$/.test(parts[1]) && /^\d{2}:\d{2}$/.test(parts[2])) {
                  explicitDate = parts[1];
                  explicitTime = parts[2];
                  isBackfill = parts.slice(3).map((s) => s.toLowerCase()).includes(BACKFILL_KEYWORD);
                }
              }

              return { cmd, explicitDate, explicitTime, isBackfill };
            }

            function parseEventFromCommentBody(body) {
              if (!body) return null;
              const start = body.indexOf(EVENT_PREFIX);
              if (start < 0) return null;

              const jsonStart = start + EVENT_PREFIX.length;
              const end = body.indexOf(EVENT_SUFFIX, jsonStart);
              if (end < 0) return null;

              const jsonText = body.slice(jsonStart, end).trim();
              try {
                const evt = JSON.parse(jsonText);
                if (!evt || typeof evt !== 'object') return null;

                if (evt.cmd !== 'sleep' && evt.cmd !== 'wake' && evt.cmd !== 'undo') return null;
                if (typeof evt.id !== 'number') return null;

                if (evt.cmd === 'undo') {
                  if (typeof evt.revokes !== 'number') return null;
                  evt.source = evt.source || 'live';
                  return evt;
                }

                if (!evt.stamp || !evt.dateKey) return null;
                if (!/^\d{4}-\d{2}-\d{2}$/.test(evt.dateKey)) return null;
                if (!/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(evt.stamp)) return null;
                evt.source = evt.source || 'live';
                return evt;
              } catch {
                return null;
              }
            }

            async function createComment(owner, repo, issue_number, body) {
              const res = await github.rest.issues.createComment({ owner, repo, issue_number, body });
              return res.data; // includes id, created_at
            }

            async function updateComment(owner, repo, comment_id, body) {
              await github.rest.issues.updateComment({ owner, repo, comment_id, body });
            }

            function buildEventComment(evt) {
              if (evt.cmd === 'undo') {
                return (
                  `Recorded **Undo**: revoked event **${evt.revokes}**\n` +
                  `${EVENT_PREFIX}${JSON.stringify(evt)} ${EVENT_SUFFIX}`
                );
              }

              const action = evt.cmd === 'sleep' ? 'Sleep' : 'Wake';
              const extra = evt.source === 'backfill' ? ' (backfill)' : '';
              return (
                `Recorded **${action}**${extra}: **${evt.stamp} (UTC+8)**\n` +
                `${EVENT_PREFIX}${JSON.stringify(evt)} ${EVENT_SUFFIX}`
              );
            }

            async function listCommentsPage(owner, repo, issue_number, page, per_page = 100) {
              const res = await github.rest.issues.listComments({ owner, repo, issue_number, per_page, page });
              return res.data || [];
            }

            async function listAllComments(owner, repo, issue_number) {
              const per_page = 100;
              let page = 1;
              const all = [];
              while (true) {
                const items = await listCommentsPage(owner, repo, issue_number, page, per_page);
                all.push(...items);
                if (items.length < per_page) break;
                page += 1;
              }
              return all;
            }

            async function buildTrustedEventsFull(owner, repo, issue_number) {
              const comments = await listAllComments(owner, repo, issue_number);

              const events = [];
              for (const c of comments) {
                if (c.user?.login !== TRUSTED_EVENT_AUTHOR) continue;
                const evt = parseEventFromCommentBody(c.body || '');
                if (!evt) continue;
                if (evt.id !== c.id) continue; // defense-in-depth
                evt._comment_created_at = c.created_at;
                events.push(evt);
              }

              events.sort((a, b) => (a._comment_created_at < b._comment_created_at ? -1 : 1));
              return events;
            }

            function buildMapFromEvents(events) {
              const revoked = new Set();
              for (const evt of events) {
                if (evt.cmd === 'undo') revoked.add(evt.revokes);
              }

              const map = new Map();

              for (const evt of events) {
                if (evt.cmd === 'undo') continue;
                if (revoked.has(evt.id)) continue;

                const e = map.get(evt.dateKey) || { sleep: '', wake: '', duration: '', source: '' };

                if (evt.cmd === 'sleep') {
                  if (!e.sleep || evt.stamp >= e.sleep) e.sleep = evt.stamp;
                } else {
                  if (!e.wake || evt.stamp >= e.wake) e.wake = evt.stamp;
                }

                if (e.source !== 'backfill') e.source = evt.source || 'live';
                computeDuration(e);
                map.set(evt.dateKey, e);
              }

              // cursor = latest trusted event comment id, or 0
              const cursor = events.length ? Math.max(...events.map((e) => e.id)) : 0;
              return { map, cursor };
            }

            function canSetField(oldStamp, newFullStamp, isBackfill, eventStamp) {
              if (oldStamp) return newFullStamp >= oldStamp;
              if (!isBackfill) return newFullStamp >= eventStamp;
              return true;
            }

            async function findOtherOpenSleepLogIssueUrl(owner, repo, issueAuthor, currentIssueNumber) {
              const per_page = 100;
              let page = 1;

              while (true) {
                const res = await github.rest.issues.listForRepo({
                  owner,
                  repo,
                  state: 'open',
                  labels: REQUIRED_LABEL,
                  per_page,
                  page,
                });

                const items = res.data || [];
                for (const it of items) {
                  if (it.pull_request) continue;
                  if (it.user?.login !== issueAuthor) continue;
                  if (it.number === currentIssueNumber) continue;
                  return it.html_url;
                }

                if (items.length < per_page) break;
                page += 1;
              }

              return null;
            }

            // ----------------------------
            // Start
            // ----------------------------
            const parsed = parseCommand(context.payload.comment.body);
            if (!parsed) return;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            const issueRes = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = issueRes.data;

            const commenter = context.payload.comment.user.login;
            const issueAuthor = issue.user?.login;

            if (!issueAuthor || commenter !== issueAuthor) return;

            // Title normalize
            const desiredTitle = `${TITLE_PREFIX} @${issueAuthor}`;
            if (!issue.title?.includes(`@${issueAuthor}`)) {
              await github.rest.issues.update({ owner, repo, issue_number, title: desiredTitle });
            }

            // label list
            let labels = (issue.labels || []).map((l) => (typeof l === 'string' ? l : l.name)).filter(Boolean);

            // Single-open-issue policy
            const enforceSingleIssue = async () => {
              if (!ENFORCE_SINGLE_OPEN_ISSUE_PER_USER) return true;

              const otherUrl = await findOtherOpenSleepLogIssueUrl(owner, repo, issueAuthor, issue_number);
              if (!otherUrl) return true;

              await createComment(
                owner,
                repo,
                issue_number,
                `@${commenter} ⚠️ 为了避免记录分散，你只能拥有 **一个** 处于 open 状态的 sleep-log issue。\n` +
                  `请到这个 issue 继续记录：${otherUrl}\n\n` +
                  `接下来你可以：\n` +
                  `1) 关闭当前这个 issue；\n` +
                  `2) 到上面链接的 issue 里继续记录；\n` +
                  `3) 如果那个 issue 被误关了，reopen 后即可继续使用。`
              );
              return false;
            };

            // Enable label on first use when marker exists
            if (!labels.includes(REQUIRED_LABEL)) {
              const issueBody = issue.body || '';
              const hasMarker = issueBody.includes('<!-- SLEEP_LOG_ENABLED -->');
              if (!hasMarker) return;

              const ok = await enforceSingleIssue();
              if (!ok) return;

              await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [REQUIRED_LABEL] });
              labels.push(REQUIRED_LABEL);

              await createComment(owner, repo, issue_number, `@${commenter} ✅ 已自动启用 sleep-log 功能。`);
            }

            // Always enforce for every command
            const okSingle = await enforceSingleIssue();
            if (!okSingle) return;

            // Event time (UTC+8)
            const eventUtc8 = toUtc8Date(context.payload.comment.created_at);
            const eventStamp = fmtUtc8Stamp(eventUtc8);
            const eventDateKey = fmtUtc8DateKey(eventUtc8);

            // Load latest issue body (for state/table updates)
            const latestIssueRes = await github.rest.issues.get({ owner, repo, issue_number });
            const latestIssue = latestIssueRes.data;
            const ensured = ensureTableBlock(latestIssue.body || '');
            const state = parseStateFromBody(ensured.body);

            // Decide mode
            const forceFullRebuild = parsed.cmd === '/rebuild' || parsed.cmd === '/undo' || !state;

            // Build working map
            let map = new Map();
            let cursor = 0;

            async function writeBodyWithTableAndState(mapToWrite, cursorToWrite, noteIfNoEvents) {
              const latest2 = await github.rest.issues.get({ owner, repo, issue_number });
              const ensured2 = ensureTableBlock(latest2.data.body || '');
              const { before, after } = extractTable(ensured2.body, ensured2.startMark, ensured2.endMark);

              // If map empty: keep existing table (do not overwrite) but ensure blocks+state exist
              if (mapToWrite.size === 0) {
                let bodyKeep = ensured2.body;
                const st = { cursor: cursorToWrite || 0, rows: {} };
                bodyKeep = upsertStateIntoBody(bodyKeep, st);

                if ((latest2.data.body || '') !== bodyKeep) {
                  await github.rest.issues.update({ owner, repo, issue_number, body: bodyKeep });
                }

                if (noteIfNoEvents) {
                  await createComment(
                    owner,
                    repo,
                    issue_number,
                    `@${commenter} ℹ️ 当前未检测到可信事件日志（SLEEP_LOG_EVENT），已保持现有表格不变。\n` +
                      `当首次成功记录后，表格将以事件日志为准自动重建（也可用 \`/rebuild\`）。`
                  );
                }
                return;
              }

              const middle = buildTableMiddle(mapToWrite, eventDateKey);
              let finalBody = before + middle + after;

              // write state
              const stateObj = { cursor: cursorToWrite || 0, rows: buildMapToRowsObject(mapToWrite) };
              finalBody = upsertStateIntoBody(finalBody, stateObj);

              await github.rest.issues.update({ owner, repo, issue_number, body: finalBody });
            }

            async function fullRebuildAndWrite({ commentOnNoEvents } = { commentOnNoEvents: false }) {
              const events = await buildTrustedEventsFull(owner, repo, issue_number);
              const rebuilt = buildMapFromEvents(events);
              map = rebuilt.map;
              cursor = rebuilt.cursor;

              await writeBodyWithTableAndState(map, cursor, commentOnNoEvents && map.size === 0);
              return { map, cursor };
            }

            function applyEventToMap(mapRef, evt) {
              // evt: sleep|wake with stamp/dateKey/source
              const entry = mapRef.get(evt.dateKey) || { sleep: '', wake: '', duration: '', source: '' };

              if (evt.cmd === 'sleep') {
                if (!entry.sleep || evt.stamp >= entry.sleep) entry.sleep = evt.stamp;
              } else if (evt.cmd === 'wake') {
                if (!entry.wake || evt.stamp >= entry.wake) entry.wake = evt.stamp;
              }

              if (entry.source !== 'backfill') entry.source = evt.source || 'live';
              computeDuration(entry);
              mapRef.set(evt.dateKey, entry);
            }

            // Init map/cursor either from state (fast) or full rebuild (slow)
            if (forceFullRebuild) {
              await fullRebuildAndWrite({ commentOnNoEvents: true });

              if (parsed.cmd === '/rebuild') {
                await createComment(owner, repo, issue_number, `@${commenter} ✅ 已从事件日志重建表格。`);
                return;
              }
              // For /undo we still need to continue handling below, because /undo isn't just rebuild.
              // (We'll handle /undo by using full events list again to find the latest revocable event.)
            } else {
              // Fast path: trust cached state rows
              cursor = state.cursor;
              map = buildRowsObjectToMap(state.rows);

              // Ensure table block exists and state exists (but don't overwrite table here)
              // We'll rewrite after successful record.
              const ensuredBody = ensured.body;
              if (!ensuredBody.includes(STATE_PREFIX)) {
                const newBody = upsertStateIntoBody(ensuredBody, state);
                if ((latestIssue.body || '') !== newBody) {
                  await github.rest.issues.update({ owner, repo, issue_number, body: newBody });
                }
              }
            }

            // /undo handler (always uses full rebuild/events for correctness)
            if (parsed.cmd === '/undo') {
              const events = await buildTrustedEventsFull(owner, repo, issue_number);

              // Build revoked set
              const revoked = new Set();
              for (const e of events) if (e.cmd === 'undo') revoked.add(e.revokes);

              const candidates = events
                .filter((e) => e.cmd === 'sleep' || e.cmd === 'wake')
                .filter((e) => !revoked.has(e.id))
                .sort((a, b) => (a._comment_created_at < b._comment_created_at ? 1 : -1));

              const target = candidates[0];
              if (!target) {
                await createComment(owner, repo, issue_number, `@${commenter} ⚠️ 没有找到可撤销的记录（sleep/wake）。`);
                return;
              }

              const diffMin = Math.round((new Date(context.payload.comment.created_at).getTime() - new Date(target._comment_created_at).getTime()) / 60000);
              const targetUtc8 = toUtc8Date(target._comment_created_at);
              const targetStampUtc8 = fmtUtc8Stamp(targetUtc8);

              if (diffMin > UNDO_MAX_MINUTES) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ⚠️ 只能撤销最近 **${UNDO_MAX_MINUTES}** 分钟内的记录。\n` +
                    `最近一次记录时间：**${targetStampUtc8}**（UTC+8）\n` +
                    `距现在约：**${diffMin}** 分钟`
                );
                return;
              }

              // Create placeholder comment -> update with undo event (needs id)
              const placeholder = await createComment(owner, repo, issue_number, `Recording undo...`);
              const undoEvt = { id: placeholder.id, cmd: 'undo', revokes: target.id, at: eventStamp, source: 'live' };
              await updateComment(owner, repo, placeholder.id, buildEventComment(undoEvt));

              // Full rebuild + write state/table
              await fullRebuildAndWrite({ commentOnNoEvents: false });

              await createComment(
                owner,
                repo,
                issue_number,
                `@${commenter} ✅ 已撤销最近一次记录：**${target.cmd}**（事件 ID: ${target.id}）。`
              );
              return;
            }

            // If we are in fast path, we can optionally apply new events since cursor to keep state in sync.
            // But we don't strictly need to, because only bot writes events; and each command will add one new event.
            // We keep it minimal: rely on state + this command's event.

            // Resolve dateKey/stamp for /sleep /wake
            const findLatestIncompleteDateKey = () => {
              const keys = Array.from(map.keys()).sort((a, b) => (a < b ? 1 : -1));
              for (const k of keys) {
                const e = map.get(k);
                if (e && e.sleep && !e.wake) return k;
              }
              return null;
            };

            let appliedDateKey = null;
            let targetStamp = null;
            let source = 'live';

            if (!parsed.explicitTime) {
              if (parsed.cmd === '/sleep') {
                appliedDateKey = dateKeyForSleepEvent(eventUtc8);
                targetStamp = eventStamp;
              } else {
                appliedDateKey = findLatestIncompleteDateKey() || eventDateKey;
                targetStamp = eventStamp;
              }
            } else if (parsed.explicitTime && !parsed.explicitDate) {
              await createComment(
                owner,
                repo,
                issue_number,
                `@${commenter} ⚠️ 不支持 \`${parsed.cmd} HH:MM\` 格式。\n` +
                  `请使用：\n` +
                  `- \`${parsed.cmd}\` 记录当前时间\n` +
                  `- \`${parsed.cmd} YYYY-MM-DD HH:MM backfill\` 补记/修正（仅允许最近 ${BACKFILL_MAX_DAYS} 天）`
              );
              return;
            } else if (parsed.explicitDate && parsed.explicitTime) {
              if (!parsed.isBackfill) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ⚠️ 指定日期和时间修改记录时，必须在命令末尾加上 \`backfill\` 关键字。\n` +
                    `正确格式：\`${parsed.cmd} ${parsed.explicitDate} ${parsed.explicitTime} backfill\``
                );
                return;
              }

              appliedDateKey = parsed.explicitDate;
              targetStamp = `${parsed.explicitDate} ${parsed.explicitTime}`;
              source = 'backfill';

              const todayKey = eventDateKey;
              const minAllowed = addDaysToUtc8DateKey(todayKey, -BACKFILL_MAX_DAYS);

              if (minAllowed && (appliedDateKey < minAllowed || appliedDateKey > todayKey)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ⚠️ Backfill 仅允许最近 **${BACKFILL_MAX_DAYS}** 天（**${minAllowed}** ~ **${todayKey}**）。\n` +
                    `你尝试修改的日期：**${appliedDateKey}**`
                );
                return;
              }

              if (targetStamp > eventStamp) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ⚠️ Backfill 不能填写未来时间。\n` +
                    `你输入：**${targetStamp}**\n` +
                    `当前时间：**${eventStamp}**（UTC+8）`
                );
                return;
              }
            }

            if (!appliedDateKey || !targetStamp) return;

            const entry = map.get(appliedDateKey) || { sleep: '', wake: '', duration: '', source: '' };

            if (parsed.cmd === '/sleep') {
              if (entry.sleep && source !== 'backfill') {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ${appliedDateKey} 已经记录过 **Sleep**：**${entry.sleep}**。\n` +
                    `如需修正，请使用：\n` +
                    `\`/sleep ${appliedDateKey} HH:MM backfill\`\n` +
                    `（仅允许最近 ${BACKFILL_MAX_DAYS} 天，且只能把时间改得更晚；也可用 \`/undo\` 撤销最近一次误操作）`
                );
                return;
              }

              if (entry.wake && targetStamp >= entry.wake) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ❌ 不能把 **Sleep** 设为 **${targetStamp}**，因为它晚于或等于已记录的 **Wake**（**${entry.wake}**）。`
                );
                return;
              }

              if (!canSetField(entry.sleep, targetStamp, source === 'backfill', eventStamp)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} 不允许把 **Sleep** 改得更早。\n当前：**${entry.sleep || '(empty)'}**\n尝试：**${targetStamp}**`
                );
                return;
              }

              entry.sleep = targetStamp;
            } else {
              if (entry.wake && source !== 'backfill') {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ${appliedDateKey} 已经记录过 **Wake**：**${entry.wake}**。\n` +
                    `如需修正，请使用：\n` +
                    `\`/wake ${appliedDateKey} HH:MM backfill\`\n` +
                    `（仅允许最近 ${BACKFILL_MAX_DAYS} 天，且只能把时间改得更晚；也可用 \`/undo\` 撤销最近一次误操作）`
                );
                return;
              }

              if (entry.sleep && targetStamp <= entry.sleep) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ❌ 不能把 **Wake** 设为 **${targetStamp}**，因为它早于或等于已记录的 **Sleep**（**${entry.sleep}**）。`
                );
                return;
              }

              if (!canSetField(entry.wake, targetStamp, source === 'backfill', eventStamp)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} 不允许把 **Wake** 改得更早。\n当前：**${entry.wake || '(empty)'}**\n尝试：**${targetStamp}**`
                );
                return;
              }

              entry.wake = targetStamp;
            }

            if (entry.source !== 'backfill') entry.source = source;
            computeDuration(entry);
            map.set(appliedDateKey, entry);

            // Record trusted event comment with stable id (placeholder then update)
            const placeholder = await createComment(owner, repo, issue_number, `Recording event...`);
            const evt = {
              id: placeholder.id,
              cmd: parsed.cmd === '/sleep' ? 'sleep' : 'wake',
              stamp: targetStamp,
              dateKey: appliedDateKey,
              source,
            };
            await updateComment(owner, repo, placeholder.id, buildEventComment(evt));

            // Apply event to map already done; update cursor to include this comment id
            cursor = Math.max(cursor || 0, placeholder.id);

            // Write table + state (do not keep old table)
            await writeBodyWithTableAndState(map, cursor, false);
